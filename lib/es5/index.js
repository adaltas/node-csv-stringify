'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Generated by CoffeeScript 2.0.3
// # CSV Stringifier

// Please look at the [README], the [samples] and the [tests] for additional
// information.
var Stringifier, get, stream, util;

stream = require('stream');

util = require('util');

get = require('lodash.get');

// ## Usage

// This module export a function as its main entry point and return a transform
// stream.

// Refers to the [official prject documentation](http://csv.adaltas.com/stringify/)
// on how to call this function.
module.exports = function () {
  var callback, chunks, data, options, stringifier;
  if (arguments.length === 3) {
    data = arguments[0];
    options = arguments[1];
    callback = arguments[2];
  } else if (arguments.length === 2) {
    if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
    if (typeof arguments[1] === 'function') {
      callback = arguments[1];
    } else {
      options = arguments[1];
    }
  } else if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      callback = arguments[0];
    } else if (Array.isArray(arguments[0])) {
      data = arguments[0];
    } else {
      options = arguments[0];
    }
  }
  if (options == null) {
    options = {};
  }
  stringifier = new Stringifier(options);
  if (data) {
    process.nextTick(function () {
      var d, j, len;
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        stringifier.write(d);
      }
      return stringifier.end();
    });
  }
  if (callback) {
    chunks = [];
    stringifier.on('readable', function () {
      var chunk, results;
      results = [];
      while (chunk = stringifier.read()) {
        results.push(chunks.push(chunk));
      }
      return results;
    });
    stringifier.on('error', function (err) {
      return callback(err);
    });
    stringifier.on('end', function () {
      return callback(null, chunks.join(''));
    });
  }
  return stringifier;
};

// You can also use *util.promisify* native function (Node.js 8+) in order to wrap callbacks into promises for more convenient use when source is a readable stream and you are OK with storing entire result set in memory:

// ```
// const { promisify } = require('util');
// const csv = require('csv');
// const stringifyAsync = promisify(csv.stringify);

// //returns promise
// function generateCsv(sourceData) {
//     return stringifyAsync(sourceData);
// }
// ```

// ## `Stringifier([options])`

// Options are documented [here](http://csv.adaltas.com/stringify/).
Stringifier = function Stringifier() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var base, base1, base10, base11, base12, base13, base2, base3, base4, base5, base6, base7, base8, base9, k, options, v;
  // Immutable options
  options = {};
  for (k in opts) {
    v = opts[k];
    options[k] = v;
  }
  stream.Transform.call(this, options);
  //# Default options
  this.options = options;
  if ((base = this.options).delimiter == null) {
    base.delimiter = ',';
  }
  if ((base1 = this.options).quote == null) {
    base1.quote = '"';
  }
  if ((base2 = this.options).quoted == null) {
    base2.quoted = false;
  }
  if ((base3 = this.options).quotedEmpty == null) {
    base3.quotedEmpty = void 0;
  }
  if ((base4 = this.options).quotedString == null) {
    base4.quotedString = false;
  }
  if ((base5 = this.options).eof == null) {
    base5.eof = true;
  }
  if ((base6 = this.options).escape == null) {
    base6.escape = '"';
  }
  if ((base7 = this.options).columns == null) {
    base7.columns = null;
  }
  if ((base8 = this.options).header == null) {
    base8.header = false;
  }
  if ((base9 = this.options).formatters == null) {
    base9.formatters = {};
  }
  if ((base10 = this.options.formatters).date == null) {
    base10.date = function (value) {
      // Cast date to timestamp string by default
      return '' + value.getTime();
    };
  }
  if ((base11 = this.options.formatters).bool == null) {
    base11.bool = function (value) {
      // Cast boolean to string by default
      if (value) {
        return '1';
      } else {
        return '';
      }
    };
  }
  if ((base12 = this.options.formatters).object == null) {
    base12.object = function (value) {
      // Stringify object as JSON by default
      return JSON.stringify(value);
    };
  }
  if ((base13 = this.options).rowDelimiter == null) {
    base13.rowDelimiter = '\n';
  }
  // Internal usage, state related
  if (this.countWriten == null) {
    this.countWriten = 0;
  }
  switch (this.options.rowDelimiter) {
    case 'auto':
      this.options.rowDelimiter = null;
      break;
    case 'unix':
      this.options.rowDelimiter = "\n";
      break;
    case 'mac':
      this.options.rowDelimiter = "\r";
      break;
    case 'windows':
      this.options.rowDelimiter = "\r\n";
      break;
    case 'ascii':
      this.options.rowDelimiter = '\x1E';
      break;
    case 'unicode':
      this.options.rowDelimiter = '\u2028';
  }
  return this;
};

util.inherits(Stringifier, stream.Transform);

module.exports.Stringifier = Stringifier;

// ## `Stringifier.prototype.headers`

// Print the header line if the option "header" is "true".
Stringifier.prototype.headers = function () {
  var k, label, labels;
  if (!this.options.header) {
    return;
  }
  if (!this.options.columns) {
    return;
  }
  labels = this.options.columns;
  // If columns is an object, keys are fields and values are labels
  if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) === 'object') {
    labels = function () {
      var results;
      results = [];
      for (k in labels) {
        label = labels[k];
        results.push(label);
      }
      return results;
    }();
  }
  if (this.options.eof) {
    labels = this.stringify(labels) + this.options.rowDelimiter;
  } else {
    labels = this.stringify(labels);
  }
  return stream.Transform.prototype.write.call(this, labels);
};

Stringifier.prototype.end = function (chunk, encoding, callback) {
  if (this.countWriten === 0) {
    this.headers();
  }
  return stream.Transform.prototype.end.apply(this, arguments);
};

Stringifier.prototype.write = function (chunk, encoding, callback) {
  var base, e, preserve;
  if (chunk == null) {
    return;
  }
  preserve = (typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) !== 'object';
  // Emit and stringify the record
  if (!preserve) {
    if (this.countWriten === 0 && !Array.isArray(chunk)) {
      if ((base = this.options).columns == null) {
        base.columns = Object.keys(chunk);
      }
    }
    try {
      this.emit('record', chunk, this.countWriten);
    } catch (error) {
      e = error;
      return this.emit('error', e);
    }
    // Convert the record into a string
    if (this.options.eof) {
      chunk = this.stringify(chunk) + this.options.rowDelimiter;
    } else {
      chunk = this.stringify(chunk);
      if (this.options.header || this.countWriten) {
        chunk = this.options.rowDelimiter + chunk;
      }
    }
  }
  if (typeof chunk === 'number') {
    // Emit the csv
    chunk = '' + chunk;
  }
  if (this.countWriten === 0) {
    this.headers();
  }
  if (!preserve) {
    this.countWriten++;
  }
  return stream.Transform.prototype.write.call(this, chunk, encoding, callback);
};

// ## `Stringifier.prototype._transform(line)`
Stringifier.prototype._transform = function (chunk, encoding, callback) {
  this.push(chunk);
  return callback();
};

// ## `Stringifier.prototype.stringify(line)`

// Convert a line to a string. Line may be an object, an array or a string.
Stringifier.prototype.stringify = function (line) {
  var _line, column, columns, containsEscape, containsQuote, containsRowDelimiter, containsdelimiter, delimiter, escape, field, i, j, l, newLine, quote, ref, ref1, regexp, shouldQuote, value;
  if ((typeof line === 'undefined' ? 'undefined' : _typeof(line)) !== 'object') {
    return line;
  }
  columns = this.options.columns;
  if ((typeof columns === 'undefined' ? 'undefined' : _typeof(columns)) === 'object' && columns !== null && !Array.isArray(columns)) {
    columns = Object.keys(columns);
  }
  delimiter = this.options.delimiter;
  quote = this.options.quote;
  escape = this.options.escape;
  if (!Array.isArray(line)) {
    _line = [];
    if (columns) {
      for (i = j = 0, ref = columns.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        column = columns[i];
        value = get(line, column);
        _line[i] = typeof value === 'undefined' || value === null ? '' : value;
      }
    } else {
      for (column in line) {
        _line.push(line[column]);
      }
    }
    line = _line;
    _line = null;
  } else if (columns) {
    // Note, we used to have @options.columns
    // We are getting an array but the user want specified output columns. In
    // this case, we respect the columns indexes
    line.splice(columns.length);
  }
  if (Array.isArray(line)) {
    newLine = '';
    for (i = l = 0, ref1 = line.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      field = line[i];
      if (typeof field === 'string') {

        // fine 99% of the cases, keep going
      } else if (typeof field === 'number') {
        // Cast number to string
        field = '' + field;
      } else if (typeof field === 'boolean') {
        field = this.options.formatters.bool(field);
      } else if (field instanceof Date) {
        field = this.options.formatters.date(field);
      } else if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object' && field !== null) {
        field = this.options.formatters.object(field);
      }
      if (field) {
        if (typeof field !== 'string') {
          return this.emit('error', Error('Formatter must return a string, null or undefined'));
        }
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = quote !== '' && field.indexOf(quote) >= 0;
        containsEscape = field.indexOf(escape) >= 0 && escape !== quote;
        containsRowDelimiter = field.indexOf(this.options.rowDelimiter) >= 0;
        shouldQuote = containsQuote || containsdelimiter || containsRowDelimiter || this.options.quoted || this.options.quotedString && typeof line[i] === 'string';
        if (shouldQuote && containsEscape) {
          regexp = escape === '\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');
          field = field.replace(regexp, escape + escape);
        }
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (shouldQuote) {
          field = quote + field + quote;
        }
        newLine += field;
      } else if (this.options.quotedEmpty || this.options.quotedEmpty == null && line[i] === '' && this.options.quotedString) {
        newLine += quote + quote;
      }
      if (i !== line.length - 1) {
        newLine += delimiter;
      }
    }
    line = newLine;
  }
  return line;
};

// [readme]: https://github.com/wdavidw/node-csv-stringify
// [samples]: https://github.com/wdavidw/node-csv-stringify/tree/master/samples
// [tests]: https://github.com/wdavidw/node-csv-stringify/tree/master/test